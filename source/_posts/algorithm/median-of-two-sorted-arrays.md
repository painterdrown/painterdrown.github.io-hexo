---
title: Median of Two Sorted Arrays
date: 2018-01-08 15:48:35
tags: [algorithm]
---

## 前言

- 本博客作为《算法与设计》课程第 18 周的作业
- 题目来源：[LeetCode #4](https://leetcode.com/problems/median-of-two-sorted-arrays)
- 题目类型：Divide and Conquer
- 编程语言：C++
- 运行结果：![](images/result.png)

## 问题描述

![](images/description.png)

## 问题分析

### 方案一

假设两个数组总共有 (m+n) 个元素，那么显然我们有用 O(m) 时间和 O(n) 空间的方法：用 Merge Sort 的思路排序，排序好的数组取出下标为 (m+n)/2 的元素就是我们需要的答案。

这个方法比较容易想到，但是时间复杂度是 O(m+n)，而题目要求的是 O(log(m+n))。所以还是想办法另辟蹊径！

### 方案二

我们可以发现，现在我们是不需要“排序”这么复杂的操作的，因为我们仅仅需要中位数。我们可以用一个计数器，记录当前已经找到第 m 大的元素了。同时我们使用两个指针 pA 和 pB，分别指向 A 和 B 数组的第一个元素。

使用类似于 Merge Sort 的原理：
  + 如果数组 A 当前元素小，那么 pA++，同时 m++。
  + 如果数组 B 当前元素小，那么 pB++，同时 m++。

最终当 m 等于 (m+n)/2 的时候，就找到所求元素了。

但是！时间复杂度还是跟方案一一样，还是得继续脑洞！

### 方案三

将原问题转变成一个寻找第 k 小数的问题（假设两个原序列升序排列），这样中位数实际上是第 (m+n)/2 小的数。所以只要解决了第 k 小数的问题，原问题也得以解决。

首先假设数组 A 和 B 的元素个数都大于 k/2，我们比较 A[k/2-1] 和 B[k/2-1] 两个元素，这两个元素分别表示 A 的第 k/2 小的元素和 B 的第 k/2 小的元素。这两个元素比较共有三种情况：>、< 和 =。

如果 A[k/2-1] < B[k/2-1]，这表示 A[0] 到 A[k/2-1] 的元素都在A和B合并之后的前 k 小的元素中。换句话说，A[k/2-1] 不可能大于两数组合并之后的第k小值，所以我们可以将其抛弃。

证明也很简单，可以采用反证法。假设 A[k/2-1] 大于合并之后的第k小值，我们不妨假定其为第 (k+1) 小值。由于 A[k/2-1] 小于 B[k/2-1]，所以 B[k/2-1] 至少是第 (k+2) 小值。但实际上，在 A 中至多存在 k/2-1 个元素小于 A[k/2-1]，B 中也至多存在 k/2-1 个元素小于 A[k/2-1]，所以小于 A[k/2-1] 的元素个数至多有 k/2+k/2-2，小于 k，这与 A[k/2-1] 是第 (k+1) 的数矛盾。

  + 当 A[k/2-1] > B[k/2-1] 时，存在类似的结论。
  + 当 A[k/2-1] = B[k/2-1] 时，我们已经找到了第 k 小的数，也即这个相等的元素，我们将其记为 m。由于在 A 和 B 中分别有 k/2-1 个元素小于 m，所以 m 即是第 k 小的数。
  
这里可能有人会有疑问，如果 k 为奇数，则 m 不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求 k/2，然后利用 k-k/2 获得另一个数。

通过上面的分析，我们即可以采用递归的方式实现寻找第 k 小的数。此外我们还需要考虑几个边界条件：
  + 如果 A 或者 B 为空，则直接返回 B[k-1] 或者 A[k-1]
  + 如果 k 为 1，我们只需要返回 A[0] 和 B[0] 中的较小值
  + 如果 A[k/2-1] = B[k/2-1]，返回其中一个

## 源代码

```C++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int m = nums2.size();
        if(n > m)   //保证数组1一定最短
            return findMedianSortedArrays(nums2,nums1);
        int L1,L2,R1,R2,c1,c2,lo = 0, hi = 2*n;  //我们目前是虚拟加了'#'所以数组1是2*n长度
        while(lo <= hi)   //二分
        {
            c1 = (lo+hi)/2;  //c1是二分的结果
            c2 = m+n- c1;
            L1 = (c1 == 0)?INT_MIN:nums1[(c1-1)/2];   //map to original element
            R1 = (c1 == 2*n)?INT_MAX:nums1[c1/2];
            L2 = (c2 == 0)?INT_MIN:nums2[(c2-1)/2];
            R2 = (c2 == 2*m)?INT_MAX:nums2[c2/2];

            if(L1 > R2)
                hi = c1-1;
            else if(L2 > R1)
                lo = c1+1;
            else
                break;
        }
        return (max(L1,L2)+ min(R1,R2))/2.0;
    }
};
```
